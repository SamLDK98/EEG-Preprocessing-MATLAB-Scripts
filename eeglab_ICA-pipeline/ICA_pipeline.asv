%% ========================================================================
%%                            session setup
%% ========================================================================

% Per-run inputs
sub  = strtrim(input('Enter subject ID (e.g., sub-01): ','s'));
task = strtrim(input('Enter task name (e.g., CogAss1): ','s'));

% Project-level settings
pipeline = 'eeglab-ICA_pipeline';
root     = getProjectRootSimple();   % assumes this file lives in <root>/code/

% Paths
datasetDir = fullfile(root, 'derivatives', pipeline, sub, 'eeg');
figsDir    = fullfile(datasetDir, 'figs');
logDir     = fullfile(datasetDir, 'log');
logFile    = fullfile(logDir, 'preprocessing_log.md');

mkdir(datasetDir);
mkdir(figsDir);
mkdir(logDir);

% Filenames/stems
stem      = sprintf('%s_task-%s', sub, task);
startfile = sprintf('%s_desc-rawimport_eeg.set', stem);  % output from your import/audit stage

% Load starting dataset
startpath = fullfile(datasetDir, startfile);
EEG = pop_loadset('filename', startfile, 'filepath', datasetDir);

% Save chanlocs coords
MASTER_CHANLOCS = EEG.chanlocs;

% Saver for checkpoints
saveSet = @(desc,EEGvar) pop_saveset(EEGvar, ...
    'filename', sprintf('%s_desc-%s_eeg.set', stem, desc), ...
    'filepath', datasetDir);
saveFig = @(suffix) saveas(gcf, fullfile(figsDir, sprintf('%s_%s.png', stem, suffix)));

% log
fid = fopen(logFile, 'a');
fprintf(fid, '\n\n');
fprintf(fid, '# Preprocessing for ERP: ICA Preparation for %s_task-%s\n', sub, task);
fprintf(fid, 'Started: %s\n\n', datestr(now, 'yyyy-mm-dd HH:MM:SS'));
logMsg = @(varargin) ...
    fprintf(fid, '%s%s\n', ...
        startsWith(string(varargin{1}), '#') * newline, ... % add \n if header
        sprintf(varargin{:}));

%% ========================================================================
%%                           ica workflow
%% ========================================================================

%% 1. Record original montage
EEG.etc.orig_chanlocs = EEG.chanlocs;
logMsg('- Recorded original montage (saved in EEG.etc.orig_chanlocs)');


%% 2. Trim settling period - enter 1st stimulus index!

ev   = EEG.event;
tSec = ([ev.latency]-1)/EEG.srate + EEG.xmin;
k    = min(10, numel(ev));
fprintf('\nFirst %d events:\n', k);
for i=1:k, fprintf('  %3d : %s @ %.3f\n', i, string(ev(i).type), tSec(i)); end

idx = input('Index of first real stimulus (counting from 1): ');
assert(isscalar(idx) && idx==round(idx) && idx>=1 && idx<=numel(ev), 'Bad index.');

pre    = 20;
first  = tSec(idx);
orig   = [EEG.xmin EEG.xmax];
start  = first - pre;
didTrim = start > 0 + 1/EEG.srate;

if didTrim
    EEG = pop_select(EEG, 'time', [max(start, EEG.xmin) EEG.xmax]);
    if exist('saveSet','var'), saveSet('trim20s', EEG); end
end

EEG.etc.ica_prep.trim = struct( ...
    'policy', sprintf('%ds pre-stim', pre), ...
    'idx', idx, 'type', string(ev(idx).type), ...
    'first_stim_s', first, 'applied', didTrim, ...
    'orig_range_s', orig, 'post_range_s', [EEG.xmin EEG.xmax]);

% Log

if exist('logMsg','var')
    logMsg('### Trim (manual)');
    logMsg('- First stim: idx=%d, type=%s, t=%.3f s', idx, string(ev(idx).type), first);
    if didTrim
        logMsg('- Applied: start=%.3f s (kept ~%d s pre-stim)', start, pre);
        logMsg('- Saved: %s_desc-trim20s_eeg.set', sprintf('%s_task-%s', sub, task));
    else
        logMsg('- Skipped: start=%.3f s <= 0 (assumed pre-trimmed)', start);
    end
end

%% 3. Downsampling

origSrate = EEG.srate;
fprintf('Current sampling rate: %.3f Hz\n', origSrate);
ansHz = input('New sampling rate in Hz (Enter to skip): ');

if isempty(ansHz)
    target = origSrate;   % skip
else
    target = round(ansHz);  % enforce new Hz
end

if abs(origSrate - target) <= 1e-6
    if exist('logMsg','var')
        logMsg('### Downsample');
        logMsg('- Original sampling rate already %.3f Hz → step skipped', origSrate);
    end
else
    EEG = pop_resample(EEG, target);     % anti-aliasing included
    tag = sprintf('ds%d', target);
    if exist('saveSet','var'), saveSet(tag, EEG); end

    if exist('logMsg','var')
        logMsg('### Downsample');
        logMsg('- Original sampling rate: %.3f Hz', origSrate);
        logMsg('- New sampling rate: %.3f Hz', EEG.srate);
        logMsg('- Saved as: %s_desc-%s_eeg.set', stem, tag);
    end
end

EEG.etc.ica_prep.downsample = struct( ...
    'applied', abs(origSrate-target) > 1e-6, ...
    'orig_hz', origSrate, 'target_hz', target, 'new_hz', EEG.srate);


%% 4. Line noise removal

fprintf('Line noise removal. Current sampling rate: %.3f Hz\n', EEG.srate);
f0 = input('Mains frequency [50 or 60]: ');
assert(ismember(f0,[50 60]), 'Enter 50 or 60.');
assert(exist('pop_cleanline','file')==2, 'CleanLine plugin not found on the path.');

nyq   = EEG.srate/2;
harms = f0:f0:nyq;

EEG = pop_cleanline(EEG, 'linefreqs', harms, 'chanlist', 1:EEG.nbchan);

tag = sprintf('linrm%d', f0);
if exist('saveSet','var'), saveSet(tag, EEG); end
if exist('logMsg','var')
    logMsg('### Line noise');
    logMsg('- Base: %d Hz; harmonics: %s', f0, strjoin(string(harms), ' '));
    logMsg('- Saved as: %s_desc-%s_eeg.set', stem, tag);
end

EEG.etc.ica_prep.line_noise = struct('method','cleanline','base_hz',f0,'harmonics',harms);


%% 5. High-pass - 1 Hz

orig = [EEG.xmin EEG.xmax];
EEG  = pop_eegfiltnew(EEG, 1, []); % zero-phase FIR HP at 1 Hz

if exist('saveSet','var'), saveSet('hp1', EEG); end
if exist('logMsg','var')
    logMsg('### High-pass (ICA branch)');
    logMsg('- Applied: 1 Hz high-pass (pop_eegfiltnew)');
    logMsg('- Saved as: %s_desc-hp1_eeg.set', stem);
end
EEG.etc.ica_prep.highpass = struct('cutoff_hz',1,'orig_range_s',orig,'post_range_s',[EEG.xmin EEG.xmax]);


%% 6. Gross artifact cleanup - MANUAL CHECK NEEDED

% a. channel pruning 
[EEG, removedChans] = channel_prune_workbench(EEG, saveSet, logMsg, stem);

% b. segment pruning 
[EEG, newBounds] = manual_segment_prune(EEG, saveSet, logMsg, stem);

%% 7. Bad channel removal - clean_rawdata

[EEG, T_bct] = bad_channel_triage(EEG, logFile, saveSet, stem, logMsg);

%% 8. ASR

[EEG, R] = asr_interactive(EEG, saveSet, stem, logMsg);


%% 9. Average reference

%% 9) Average reference (exclude non-EEG channels)

% Identify channels to EXCLUDE from the average (don't let these bias the ref)
nonEEG_labels = upper(string( ...
    {'HEOG','VEOG','EOG','HEOG1','HEOG2','VEOG1','VEOG2', ...
     'EMG','EMG1','EMG2','ECG','M1','M2','A1','A2'}));  % add your lab's tags

allLabs  = upper(string({EEG.chanlocs.labels}));
exclude  = find(ismember(allLabs, nonEEG_labels));

% Keep a copy of chanlocs (paranoia; reref should not touch them)
chanlocs_before = EEG.chanlocs;

% Apply average reference over EEG-only channels
EEG = pop_reref(EEG, [], 'exclude', exclude, 'refloc', []);  % avg-ref, exclude listed chans

% Restore chanlocs just in case (safe no-op if unchanged)
EEG.chanlocs = chanlocs_before;

% --- Rank estimate after average-ref
if exist('eeg_rank','file') == 2
    % Uses clean_rawdata's rank estimator (handles degenerate cases nicely)
    pcaRank = eeg_rank(double(EEG.data));
else
    % Fallback heuristic: avg-ref drops 1 DOF if data were full-rank
    pcaRank = min(rank(double(EEG.data)'), EEG.nbchan - 1);
end

% Save checkpoint
saveStep('avgRef', EEG);

% ---- Log
fid = fopen(fullfile(eegdir,'log','preprocessing_log.md'),'a');
ts  = datestr(now,'yyyy-mm-dd HH:MM:SS');
if ~isempty(exclude)
    excl_list = strjoin(string({EEG.chanlocs(exclude).labels}), ', ');
else
    excl_list = '(none)';
end
fprintf(fid, "### Re-reference — %s\n", ts);
fprintf(fid, "- Reference: average (excluding: %s)\n", excl_list);
fprintf(fid, "- Estimated rank after reref: %d\n", pcaRank);
fprintf(fid, "- Saved as: %s_desc-avgRef_eeg.set\n\n", stem);
fclose(fid);

% (Optional sanity print to console)
fprintf('Avg-ref done. Excluded %d channel(s) from the reference. Estimated rank=%d\n', numel(exclude), pcaRank);


%% 9. Run ICA (compute weights) + save checkpoints

% -- Safety: ensure we've average-referenced (recommended for ICA)
if ~isfield(EEG,'ref') || ~(ischar(EEG.ref) && strcmpi(EEG.ref,'average'))
    warning('EEG.ref does not indicate average reference. ICA is typically run after avg-ref.');
end

% -- Decide PCA rank (use existing if provided; otherwise compute safely)
if ~exist('pcaRank','var') || isempty(pcaRank) || ~isscalar(pcaRank)
    % Rank after avg-ref is usually nbchan-1; also cap by numerical rank of data
    try
        dataRank = rank(double(EEG.data'));        % robust-ish check
    catch
        dataRank = EEG.nbchan;                      % fallback
    end
    pcaRank = min([EEG.nbchan-1, dataRank]);
    fprintf('pcaRank not provided — using %d (min(nbchan-1, dataRank)).\n', pcaRank);
end

% -- Run ICA (extended runica). Use 'interrupt','on' so you can pause/stop.
fprintf('Running ICA: runica (extended=1), PCA=%d ...\n', pcaRank);
tic;
EEG = pop_runica(EEG, 'icatype','runica', 'extended',1, 'pca', pcaRank, 'interrupt','on');
t_ica = toc;
fprintf('ICA finished in %.1f min.\n', t_ica/60);

% -- Save an ICA checkpoint (weights embedded in the dataset)
saveStep('ica', EEG);

% -- Log ICA run
fid = fopen(fullfile(eegdir,'log','preprocessing_log.md'),'a');
ts  = datestr(now,'yyyy-mm-dd HH:MM:SS');
fprintf(fid, "### ICA — %s\n", ts);
fprintf(fid, "- Algorithm: runica (extended)\n");
fprintf(fid, "- PCA dim: %d\n", pcaRank);
fprintf(fid, "- Duration: %.1f min\n", t_ica/60);
fprintf(fid, "- Saved as: %s_desc-ica_eeg.set\n\n", stem);
fclose(fid);

%% =======================================================================
%%            save ICA weights (frozen owner) for transfer later
%% =======================================================================

% -- Safety checks
assert(isfield(EEG,'icaweights') && ~isempty(EEG.icaweights), 'ICA weights missing.');
assert(isfield(EEG,'icasphere')  && ~isempty(EEG.icasphere),  'ICA sphere missing.');
if ~isfield(EEG,'icachansind') || isempty(EEG.icachansind)
    EEG.icachansind = 1:EEG.nbchan;  % typical if all current channels used
end

% -- Save a canonical "ICA owner" dataset (no further edits to this one)
saveStep('icaMODEL', EEG);

% -- Also save core ICA fields to a .mat for easy attachment later
icaOut = struct();
icaOut.icaweights   = EEG.icaweights;
icaOut.icasphere    = EEG.icasphere;
icaOut.icachansind  = EEG.icachansind;
icaOut.labels       = {EEG.chanlocs.labels};
icaOut.nbchan       = EEG.nbchan;
icaOut.srate        = EEG.srate;
icaOut.ref          = getfield(EEG, 'ref', 'unknown'); %#ok<GFLD>
icaOut.pcaDim       = size(EEG.icaweights,1);
icaOut.setname      = EEG.setname;

weightsMat = fullfile(datasetDir, sprintf('%s_desc-icaWeights.mat', stem));
save(weightsMat, '-struct', 'icaOut');

% -- Log ICA model save
fid = fopen(fullfile(eegdir,'log','preprocessing_log.md'),'a');
ts  = datestr(now,'yyyy-mm-dd HH:MM:SS');
fprintf(fid,"### ICA model save — %s\n", ts);
fprintf(fid,"- Purpose: frozen owner of ICA weights (for transfer later)\n");
fprintf(fid,"- Saved dataset: %s_desc-icaMODEL_eeg.set\n", stem);
fprintf(fid,"- Saved fields: %s\n", strjoin(fieldnames(icaOut)', ', '));
fprintf(fid,"- Training conditions: HP ~1 Hz, avg-ref, bad channels removed pre-ICA\n");
fprintf(fid,"- ICA algorithm: runica (extended)\n");
fprintf(fid,"- PCA rank used: %d\n\n", pcaRank);
fclose(fid);

%% =======================================================================
%%        create second ERP branch (derive paths from current file)
%% =======================================================================

% ---- Detect current file context (subject/task/BIDS root) ----
% Prefer explicit variables if you already have them
currDir = pwd;
if exist('eegdir','var') && isfolder(eegdir), currDir = eegdir; end

% Try to get a filename to parse
if exist('stem','var')
    currName = sprintf('%s_desc-icaMODEL_eeg.set', stem);
elseif ~isempty(EEG.setname)
    currName = EEG.setname; % e.g., 'sub-01_task-CogAss_desc-ica_eeg.set'
else
    % Last resort: scan for a .set in currDir
    d = dir(fullfile(currDir,'*.set'));
    assert(~isempty(d), 'No .set found to infer subject/task.');
    currName = d(1).name;
end

% Extract sub-XX and task-XXX from filename (robust-ish)
tokSub  = regexp(currName, '(sub-[a-zA-Z0-9]+)', 'tokens', 'once');
tokTask = regexp(currName, 'task-([a-zA-Z0-9]+)', 'tokens', 'once');
assert(~isempty(tokSub),  'Could not infer subject label from filename.');
assert(~isempty(tokTask), 'Could not infer task label from filename.');
sub  = tokSub{1};         % e.g., 'sub-01'
task = tokTask{1};        % e.g., 'CogAss'

% Walk up to BIDS root (look for '/derivatives/')
parts = strsplit(currDir, filesep);
idxDeriv = find(strcmpi(parts,'derivatives'), 1, 'last');
assert(~isempty(idxDeriv), 'This script expects to run inside a BIDS /derivatives/ tree.');
bidsRoot = fullfile(parts{1:idxDeriv-1});  % <-- FIXED (no leading filesep)

% Name the ERP derivatives pipeline folder
derivName = 'eeg-ERP';  % change if you prefer another label
derivRoot = fullfile(bidsRoot, 'derivatives', derivName);

% Make top-level derivative dir
if ~exist(derivRoot,'dir'), mkdir(derivRoot); end

% ---- Ensure derivatives dataset_description.json exists ----
ddjson = fullfile(derivRoot, 'dataset_description.json');
if ~exist(ddjson, 'file')
    S = struct;
    S.Name        = derivName;
    S.BIDSVersion = '1.8.0';
    S.DatasetType = 'derivative';
    S.GeneratedBy = struct( ...
        'Name', 'ERP preprocessing (EEGLAB+ERPLAB)', ...
        'Version', '1.0.0', ...
        'Description', 'ERP branch: gentle filters, ICA transfer, ERPLAB epoching/averaging', ...
        'CodeURL', '' ...
    );
    % Optional: reference the source dataset
    S.SourceDatasets = struct('Name','', 'URL','', 'DOI','');
    txt = jsonencode(S, 'PrettyPrint', true);
    fid = fopen(ddjson,'w'); assert(fid>0, 'Cannot write dataset_description.json');
    fwrite(fid, txt, 'char'); fclose(fid);
    fprintf('Created: %s\n', ddjson);
else
    fprintf('Found existing derivatives dataset_description.json (kept): %s\n', ddjson);
end

% ---- Create subject-level folders: sub-XX/eeg/log & figs ----
subDir     = fullfile(derivRoot, sub);
eegdir_erp = fullfile(subDir, 'eeg');
logdir_erp = fullfile(eegdir_erp, 'log');
figsdir_erp= fullfile(eegdir_erp, 'figs');

cellfun(@(p) ~exist(p,'dir') && mkdir(p), {subDir, eegdir_erp, logdir_erp, figsdir_erp});

% Seed empty dirs for VCS (optional)
seed = @(p) (~exist(fullfile(p,'.gitkeep'),'file')) && fclose(fopen(fullfile(p,'.gitkeep'),'w'));
seed(logdir_erp); seed(figsdir_erp);

% ---- ERP log path & header (create if missing) ----
logPath_erp = fullfile(logdir_erp, 'preprocessing_log.md');
if ~exist(logPath_erp,'file')
    fid = fopen(logPath_erp,'w');
    ts  = datestr(now,'yyyy-mm-dd HH:MM:SS');
    fprintf(fid, "# ERP Preprocessing Log — %s (%s)\n\n", sub, ts);
    fprintf(fid, "- Derivatives branch: %s\n", derivName);
    fprintf(fid, "- Task: %s\n\n", task);
    fclose(fid);
end

% ---- Build a stem for consistent file naming in ERP branch ----
stem_erp = sprintf('%s_task-%s', sub, task);

% ---- Helper: save into ERP branch with a description tag ----
saveStepERP = @(desc, EEGin) deal( ...
    pop_saveset(EEGin, 'filename', sprintf('%s_desc-%s_eeg.set', stem_erp, desc), ...
                       'filepath', eegdir_erp), ...
    fprintf('Saved: %s\n', fullfile(eegdir_erp, sprintf('%s_desc-%s_eeg.set', stem_erp, desc))) );

% ---- Log the branch creation into your *existing* pre-ICA log as well ----
if exist('eegdir','var')
    fid = fopen(fullfile(eegdir,'log','preprocessing_log.md'),'a');
    if fid>0
        ts = datestr(now,'yyyy-mm-dd HH:MM:SS');
        fprintf(fid,"### ERP derivatives branch created — %s\n", ts);
        fprintf(fid,"- Location: %s\n", eegdir_erp);
        fprintf(fid,"- Subject: %s\n- Task: %s\n\n", sub, task);
        fclose(fid);
    end
end

fprintf('ERP derivatives ready at: %s\n', eegdir_erp);
